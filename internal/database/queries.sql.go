// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: queries.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createCategory = `-- name: CreateCategory :one
INSERT INTO categories (name)
VALUES ($1)
RETURNING id, name
`

type CreateCategoryRow struct {
	ID   pgtype.UUID `db:"id"`
	Name string      `db:"name"`
}

func (q *Queries) CreateCategory(ctx context.Context, name string) (CreateCategoryRow, error) {
	row := q.db.QueryRow(ctx, createCategory, name)
	var i CreateCategoryRow
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const createProgram = `-- name: CreateProgram :one
INSERT INTO programs (title, description, category_id, language, duration)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, title, description, language, duration
`

type CreateProgramParams struct {
	Title       string      `db:"title"`
	Description pgtype.Text `db:"description"`
	CategoryID  pgtype.UUID `db:"category_id"`
	Language    pgtype.Text `db:"language"`
	Duration    pgtype.Int4 `db:"duration"`
}

type CreateProgramRow struct {
	ID          pgtype.UUID `db:"id"`
	Title       string      `db:"title"`
	Description pgtype.Text `db:"description"`
	Language    pgtype.Text `db:"language"`
	Duration    pgtype.Int4 `db:"duration"`
}

func (q *Queries) CreateProgram(ctx context.Context, arg CreateProgramParams) (CreateProgramRow, error) {
	row := q.db.QueryRow(ctx, createProgram,
		arg.Title,
		arg.Description,
		arg.CategoryID,
		arg.Language,
		arg.Duration,
	)
	var i CreateProgramRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Language,
		&i.Duration,
	)
	return i, err
}

const deleteProgram = `-- name: DeleteProgram :exec
DELETE FROM programs WHERE id = $1
`

func (q *Queries) DeleteProgram(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteProgram, id)
	return err
}

const getCategories = `-- name: GetCategories :many
SELECT id, name
FROM categories
ORDER BY name
`

type GetCategoriesRow struct {
	ID   pgtype.UUID `db:"id"`
	Name string      `db:"name"`
}

func (q *Queries) GetCategories(ctx context.Context) ([]GetCategoriesRow, error) {
	rows, err := q.db.Query(ctx, getCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCategoriesRow
	for rows.Next() {
		var i GetCategoriesRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProgram = `-- name: GetProgram :one
SELECT
    p.id,
    p.title,
    p.description,
    p.language,
    p.duration,
    p.category_id,
    c.name as category_name
FROM programs p
LEFT JOIN categories c ON p.category_id = c.id
WHERE p.id = $1
`

type GetProgramRow struct {
	ID           pgtype.UUID `db:"id"`
	Title        string      `db:"title"`
	Description  pgtype.Text `db:"description"`
	Language     pgtype.Text `db:"language"`
	Duration     pgtype.Int4 `db:"duration"`
	CategoryID   pgtype.UUID `db:"category_id"`
	CategoryName pgtype.Text `db:"category_name"`
}

func (q *Queries) GetProgram(ctx context.Context, id pgtype.UUID) (GetProgramRow, error) {
	row := q.db.QueryRow(ctx, getProgram, id)
	var i GetProgramRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Language,
		&i.Duration,
		&i.CategoryID,
		&i.CategoryName,
	)
	return i, err
}

const getProgramsByCategory = `-- name: GetProgramsByCategory :many
SELECT
    p.id,
    p.title,
    p.description,
    p.language,
    p.duration,
    p.category_id,
    c.name as category_name
FROM programs p
JOIN categories c ON p.category_id = c.id
WHERE c.id = $1
ORDER BY p.created_at DESC
`

type GetProgramsByCategoryRow struct {
	ID           pgtype.UUID `db:"id"`
	Title        string      `db:"title"`
	Description  pgtype.Text `db:"description"`
	Language     pgtype.Text `db:"language"`
	Duration     pgtype.Int4 `db:"duration"`
	CategoryID   pgtype.UUID `db:"category_id"`
	CategoryName string      `db:"category_name"`
}

func (q *Queries) GetProgramsByCategory(ctx context.Context, id pgtype.UUID) ([]GetProgramsByCategoryRow, error) {
	rows, err := q.db.Query(ctx, getProgramsByCategory, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProgramsByCategoryRow
	for rows.Next() {
		var i GetProgramsByCategoryRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Language,
			&i.Duration,
			&i.CategoryID,
			&i.CategoryName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPrograms = `-- name: ListPrograms :many
SELECT
    p.id,
    p.title,
    p.description,
    p.language,
    p.duration,
    p.category_id,
    c.name as category_name
FROM programs p
LEFT JOIN categories c ON p.category_id = c.id
ORDER BY p.created_at DESC
`

type ListProgramsRow struct {
	ID           pgtype.UUID `db:"id"`
	Title        string      `db:"title"`
	Description  pgtype.Text `db:"description"`
	Language     pgtype.Text `db:"language"`
	Duration     pgtype.Int4 `db:"duration"`
	CategoryID   pgtype.UUID `db:"category_id"`
	CategoryName pgtype.Text `db:"category_name"`
}

func (q *Queries) ListPrograms(ctx context.Context) ([]ListProgramsRow, error) {
	rows, err := q.db.Query(ctx, listPrograms)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProgramsRow
	for rows.Next() {
		var i ListProgramsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Language,
			&i.Duration,
			&i.CategoryID,
			&i.CategoryName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchPrograms = `-- name: SearchPrograms :many
SELECT
    p.id,
    p.title,
    p.description,
    p.language,
    p.duration,
    p.category_id,
    c.name as category_name
FROM programs p
LEFT JOIN categories c ON p.category_id = c.id
WHERE p.title ILIKE '%' || $1 || '%'
   OR p.description ILIKE '%' || $1 || '%'
   OR c.name ILIKE '%' || $1 || '%'
ORDER BY p.created_at DESC
`

type SearchProgramsRow struct {
	ID           pgtype.UUID `db:"id"`
	Title        string      `db:"title"`
	Description  pgtype.Text `db:"description"`
	Language     pgtype.Text `db:"language"`
	Duration     pgtype.Int4 `db:"duration"`
	CategoryID   pgtype.UUID `db:"category_id"`
	CategoryName pgtype.Text `db:"category_name"`
}

func (q *Queries) SearchPrograms(ctx context.Context, dollar_1 pgtype.Text) ([]SearchProgramsRow, error) {
	rows, err := q.db.Query(ctx, searchPrograms, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchProgramsRow
	for rows.Next() {
		var i SearchProgramsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Language,
			&i.Duration,
			&i.CategoryID,
			&i.CategoryName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProgram = `-- name: UpdateProgram :one
UPDATE programs
SET
    title = $2,
    description = $3,
    category_id = $4,
    language = $5,
    duration = $6,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, title, description, language, duration
`

type UpdateProgramParams struct {
	ID          pgtype.UUID `db:"id"`
	Title       string      `db:"title"`
	Description pgtype.Text `db:"description"`
	CategoryID  pgtype.UUID `db:"category_id"`
	Language    pgtype.Text `db:"language"`
	Duration    pgtype.Int4 `db:"duration"`
}

type UpdateProgramRow struct {
	ID          pgtype.UUID `db:"id"`
	Title       string      `db:"title"`
	Description pgtype.Text `db:"description"`
	Language    pgtype.Text `db:"language"`
	Duration    pgtype.Int4 `db:"duration"`
}

func (q *Queries) UpdateProgram(ctx context.Context, arg UpdateProgramParams) (UpdateProgramRow, error) {
	row := q.db.QueryRow(ctx, updateProgram,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.CategoryID,
		arg.Language,
		arg.Duration,
	)
	var i UpdateProgramRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Language,
		&i.Duration,
	)
	return i, err
}
